import pandas as pd

class FileParser(ABC):
     def __init__(self):
        self._data = None
        
    @abstractmethod
    def parse_file(self, file):
        pass


# Classe per il parsing del file FASTA
class FastaParser:

    def __init__(self):
        self._data = None

    @staticmethod  #forse così? così almeno come argomento gli va bene solo function
    # Decoratore per validare la presenza del dataset caricato
    def ensure_data_loaded(func):
        def wrapper(self, *args, **kwargs):
            if self._data is None:  # o si cambia come è scritto il decoratore oppure va messo dentro la classe perchè altrimenti non può accedere direttamente al self.__data; in ogni caso dove era stato messso a decorare un'altra funzione non andava bene
                raise ValueError("Nessun dataset caricato. Caricare un file FASTA prima di eseguire l'operazione.")
            return func(self, *args, **kwargs)
        return wrapper

    def parse_file(self, file: str) -> None:
        """Effettua il parsing del file FASTA e memorizza i dati in un DataFrame."""
        sequences = []
        f = open(file, "r")
        identifier, description, sequence = None, None, '' #crea queste tre variabili
        for line in f:
            line = line.strip()  # Rimuove eventuali spazi vuoti o caratteri di nuova linea
            if line.startswith(">"):  # Identifica una nuova sequenza
                if identifier is not None:  # Se c'è già una sequenza in corso, la aggiungiamo alla lista
                    sequences.append((identifier, description, sequence))
                sequence = ""
                header_parts = line[1:].split(" ", 1)  # divide la stringa in due parti usando lo spazio " " come separatore, ma solo al primo spazio che trova.
                identifier = header_parts[0]  # Primo elemento
                description = header_parts[1] if len(header_parts) > 1 else ""  # Se presente, prende la descrizione
            else:
                sequence += line  # Aggiunge la riga
        sequences = sequences[1:] #rimuove il primo elemento che è none,none, ""
        #dobbiamo riaggiungere  if identifier != None?
        sequences.append((identifier, description, sequence)) #serve a riaggiornare le sequenze

        f.close()
        self._data = pd.DataFrame(sequences, columns=["Identifier", "Description", "Sequence"])

    """Restituisce il DataFrame contenente i dati FASTA."""
    def get_DataFrame(self):
        return self._data

    @ensure_data_loaded #se i dati non sono stati caricati non verrà eseguito.
    def get_summary(self):
        """describe(include="all") restituisce un riepilogo del dataset.: numero di valori unici per ogni colonna, frequenza degli identificatori, lunghezza media delle sequenze"""
        return self._data.describe(include="all")

    @ensure_data_loaded #aggiunto
    def get_seq(self, index):
        """Restituisce la sequenza e i dettagli della riga indicata."""
        if index >= len(self._data) or index < 0:
            raise IndexError(f"Indice {index} fuori dai limiti).")
        seq = self._data.iloc[index].tolist()
        return seq


try_fasta_parser = FastaParser()
try_fasta_parser.parse_fasta('example.fasta')
DataFrame = try_fasta_parser.get_DataFrame()
print(try_fasta_parser.get_summary())
try_fasta_parser.print_DataFrame()
print(try_fasta_parser.get_seq(3))

print('the sequence of the second row is long', len(DataFrame.loc[99, 'Sequence']))

