from flask import Flask, render_template, request, redirect, url_for, session, flash
import os
from file_processor import FastaParser, DNASequence, MotifAnalyser, SequenceAligner

"""•	Flask → Framework per creare applicazioni web
	•	render_template → Per generare pagine HTML
	•	request → Per gestire input dell’utente (es. file o form)
	•	redirect, url_for → Per reindirizzare l’utente
	•	session → Memorizza i dati temporaneamente (senza usare variabili globali)
	•	flash → Mostra messaggi di errore o conferma
	•	os → Per gestire file e cartelle
	•	file_processor → Modulo che contiene le classi per elaborare i file FASTA"""

app = Flask(__name__) #crea flask app
app.secret_key = "supersecretkey"  # Necessario per usare sessioni

UPLOAD_FOLDER = "uploads" #indica dove salvare i files
os.makedirs(UPLOAD_FOLDER, exist_ok=True)  # Assicura che la cartella esista, se non esiste la crea
app.config["UPLOAD_FOLDER"] = UPLOAD_FOLDER #salva la configurazione


@app.route("/")
def index():
    return render_template("index.html") #carica un file


@app.route("/upload", methods=["POST"])
def upload():
    if "file" not in request.files: 
        flash("No file part", "error")
        return redirect(url_for("index"))

    file = request.files["file"]
    
    if file.filename == "":
        flash("No file selected!", "error")
        return redirect(url_for("index"))

    if not file.filename.endswith(".fasta"):
        flash("Invalid file format! Please upload a .fasta file.", "error")
        return redirect(url_for("index"))

    # Salva il file sempre con lo stesso nome

    if file:
        filename = secure_filename(file.filename) #aggiunte per vedere se così mi uploada il file
    	filepath = os.path.join(app.config["UPLOAD_FOLDER"], "uploaded_file.fasta")
    	file.save(filepath)

    # Analizza il file con la classe FastaParser
    parser = FastaParser() #istanza della classe
    parser.parse_fasta(filepath) #qua vorrebbe un file, crea il file ma il metodo ritorna none
    df.fasta=parser.get_DataFrame() #DataFrame del parserd file

    session["uploaded_data_path"] = filepath  # Salviamo il percorso nella sessione
    session["fasta_data"] = parser.get_DataFrame().to_json()  # Salviamo i dati (convertiti in JSON)

    flash("File uploaded and processed successfully!", "success")
    return redirect(url_for("stats"))

"""1.	Controlla se è stato inviato un file
	2.	Verifica che il file abbia estensione .fasta
	3.	Salva il file in uploads/uploaded_file.fasta
	4.	Usa FastaParser per analizzare il file
	5.	Salva i dati nella session:
	•	Percorso del file (uploaded_data_path)
	•	Dati della sequenza convertiti in JSON (fasta_data)
	6.	Mostra un messaggio di conferma (flash) e reindirizza a /stats"""


@app.route("/stats")
def stats():
    if "fasta_data" not in session:
        flash("No data available. Please upload a file first.", "error")
        return redirect(url_for("index"))

    import pandas as pd
    fasta_data = pd.read_json(session["fasta_data"])

    stats = []
for i in range(len(pd.parser)): #la length è del dataframe
    dna_seq = MitochondrialDNA(*parser.get_seq_info(i)) #ma le info sono un metodo  della classe
    
    stats.append({
        "ID": dna_seq.get_attributes_value()[0] ,
        "Description": dna_seq.get_attributes_value()[1],
        "Length": dna_seq.length(),
        "GC Content": f"{dna_seq.gc_content():.2f}%"})

    return render_template("stats.html", stats=stats)
"""1.	Controlla se esistono dati nella session, altrimenti reindirizza l’utente alla homepage
	2.	Converte il JSON salvato in un DataFrame Pandas
	3.	Calcola statistiche su ogni sequenza (lunghezza, GC content)
	4.	Mostra i dati nella pagina stats.html"""

@app.route("/motif", methods=["GET", "POST"])
def motif():
    if "fasta_data" not in session:
        flash("No data available. Please upload a file first.", "error")
        return redirect(url_for("index"))

    import pandas as pd
    fasta_data = pd.read_json(session["fasta_data"])

    results = None
    motif = None

    if request.method == "POST":
        motif = request.form.get("motif")
        if not motif:
            flash("Please enter a motif to search for.", "error")
            return redirect(url_for("motif"))

        analyser = MotifAnalyser(pd.fasta) #per istanziare la classe bisogna dargli un dataframe
        results = analyser.find_motif(motif) #il metodo vuole solo il motivo

    return render_template("motif.html", results=results, motif=motif)
"""	•	Se l’utente inserisce un “motif”, cerca il pattern nelle sequenze
	•	Mostra i risultati in motif.html"""

@app.route("/align", methods=["GET", "POST"])
def align():
    if "fasta_data" not in session:
        flash("No data available. Please upload a file first.", "error")
        return redirect(url_for("index"))

    import pandas as pd
    fasta_data = pd.read_json(session["fasta_data"])

    alignment_result = None
    seq1_index = None
    seq2_index = None

    if request.method == "POST":
        try:
            seq1_index = int(request.form.get("seq1", -1))
            seq2_index = int(request.form.get("seq2", -1))

            if seq1_index < 0 or seq2_index < 0 or seq1_index >= len(fasta_data) or seq2_index >= len(fasta_data):
                flash("Invalid sequence selection. Please try again.", "error")
                return redirect(url_for("align"))

            seq1 = fasta_data.iloc[seq1_index]["Sequence"]
            seq2 = fasta_data.iloc[seq2_index]["Sequence"]

            aligner = SequenceAligner(seq1, seq2)
            alignment_result = aligner.align()[0]  # Prendi il miglior allineamento

        except ValueError:
            flash("Invalid input. Please select valid sequences.", "error")
            return redirect(url_for("align"))

    return render_template(
        "align.html",
        alignment_result=alignment_result,
        fasta_data=fasta_data,
        seq1_index=seq1_index,
        seq2_index=seq2_index
    )
"""	•	L’utente sceglie due sequenze da allineare
	•	Usa SequenceAligner per calcolare l’allineamento
	•	Mostra i risultati in align.html"""

if __name__ == "__main__":
    app.run(debug=True)
